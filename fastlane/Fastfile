# Fastfile for CurtainCall iOS App

default_platform(:ios)

platform :ios do
  # MARK: - Environment Setup

  REPO_ROOT = File.expand_path("..", __dir__)
  XCODEPROJ_PATH = File.join(REPO_ROOT, "CurtainCall.xcodeproj")
  SECRETS_XCCONFIG_PATH = File.join(REPO_ROOT, "CurtainCall", "Application", "Secrets.xcconfig")
  XCCONFIG_SLASH_ESCAPE = "/$()/"

  before_all do
    setup_ci if ENV['CI']
  end

  private_lane :verify_secrets_xcconfig do |options|
    expected_api_key = options[:expected_api_key].to_s.strip
    expected_base_url = options[:expected_base_url].to_s.strip

    unless File.exist?(SECRETS_XCCONFIG_PATH)
      UI.user_error!("Missing #{SECRETS_XCCONFIG_PATH}.")
    end

    content = File.read(SECRETS_XCCONFIG_PATH)
    api_key = content[/^\s*KOPIS_API_KEY\s*=\s*(.+?)\s*$/, 1].to_s.strip
    raw_base_url = content[/^\s*KOPIS_BASE_URL\s*=\s*(.+?)\s*$/, 1].to_s.strip
    normalized_base_url = raw_base_url.gsub(XCCONFIG_SLASH_ESCAPE, "//")

    if api_key.empty? || api_key.include?("$(")
      UI.user_error!("KOPIS_API_KEY is invalid in #{SECRETS_XCCONFIG_PATH}.")
    end

    if normalized_base_url.empty? || normalized_base_url.include?("$(")
      UI.user_error!("KOPIS_BASE_URL is invalid in #{SECRETS_XCCONFIG_PATH}.")
    end

    unless normalized_base_url.start_with?("http://", "https://")
      UI.user_error!("KOPIS_BASE_URL must start with http:// or https://")
    end

    if !expected_api_key.empty? && api_key != expected_api_key
      UI.user_error!("KOPIS_API_KEY in #{SECRETS_XCCONFIG_PATH} does not match CI secret.")
    end

    unless expected_base_url.empty?
      normalized_expected_base_url = expected_base_url.gsub(XCCONFIG_SLASH_ESCAPE, "//")
      if normalized_base_url != normalized_expected_base_url
        UI.user_error!("KOPIS_BASE_URL in #{SECRETS_XCCONFIG_PATH} does not match CI secret.")
      end
    end

    UI.success("✅ Verified KOPIS secrets in #{SECRETS_XCCONFIG_PATH}")
  end

  private_lane :prepare_secrets_xcconfig do
    api_key = ENV["KOPIS_API_KEY"].to_s.strip
    base_url = ENV["KOPIS_BASE_URL"].to_s.strip
    escaped_base_url = base_url.gsub("//", XCCONFIG_SLASH_ESCAPE)

    # CI에서는 환경변수로 xcconfig를 생성하고, 로컬은 기존 파일을 그대로 사용한다.
    if !api_key.empty? && !base_url.empty?
      File.write(
        SECRETS_XCCONFIG_PATH,
        <<~CONFIG
          //
          // Auto-generated by fastlane
          //
          KOPIS_API_KEY = #{api_key}
          KOPIS_BASE_URL = #{escaped_base_url}
        CONFIG
      )
      UI.message("✅ Generated #{SECRETS_XCCONFIG_PATH} from environment variables")
    elsif !File.exist?(SECRETS_XCCONFIG_PATH)
      UI.user_error!(
        "Missing #{SECRETS_XCCONFIG_PATH}. Set KOPIS_API_KEY and KOPIS_BASE_URL in CI, " \
        "or create the file locally before build."
      )
    end

    verify_secrets_xcconfig(
      expected_api_key: api_key,
      expected_base_url: base_url
    )
  end

  desc "Verify KOPIS secrets injection for CI"
  lane :verify_secrets do
    prepare_secrets_xcconfig
  end

  # MARK: - Test Lanes

  desc "Run all tests"
  lane :test do
    prepare_secrets_xcconfig
    sh("rm -rf ./derived_data/ModuleCache.noindex")
    run_tests(
      project: XCODEPROJ_PATH,
      scheme: "CurtainCall",
      device: "iPhone 16 Pro",
      derived_data_path: "./derived_data",
      code_coverage: true,
      output_directory: "./test_output",
      buildlog_path: "./test_output/buildlogs"
    )
  end

  # MARK: - Build Lanes

  desc "Build the app for Debug"
  lane :build do
    prepare_secrets_xcconfig
    build_app(
      project: XCODEPROJ_PATH,
      scheme: "CurtainCall",
      configuration: "Debug",
      derived_data_path: "./derived_data",
      skip_codesigning: true,
      skip_archive: true
    )
  end

  desc "Build the app for Release"
  lane :build_release do
    prepare_secrets_xcconfig
    build_app(
      project: XCODEPROJ_PATH,
      scheme: "CurtainCall",
      configuration: "Release",
      derived_data_path: "./derived_data",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "CurtainCall.ipa"
    )
  end

  # MARK: - TestFlight Deployment

  desc "Upload a new build to TestFlight"
  lane :beta do
    prepare_secrets_xcconfig

    # Import certificate and provisioning profile
    import_certificate(
      certificate_path: ENV["P12_PATH"],
      certificate_password: ENV["P12_PASSWORD"],
      keychain_name: "fastlane_tmp_keychain"
    )

    install_provisioning_profile(
      path: ENV["PROFILE_PATH"]
    )

    # Install widget provisioning profile
    if ENV["PROFILE_WIDGET_PATH"]
      install_provisioning_profile(
        path: ENV["PROFILE_WIDGET_PATH"]
      )
    end

    # App Store Connect API Key
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
    )

    # Increment build number
    increment_build_number(
      build_number: latest_testflight_build_number + 1,
      xcodeproj: XCODEPROJ_PATH
    )

    # Build the app
    build_app(
      project: XCODEPROJ_PATH,
      scheme: "CurtainCall",
      configuration: "Release",
      derived_data_path: "./derived_data",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "CurtainCall.ipa",
      buildlog_path: "./build/logs",
      xcargs: "PROVISIONING_PROFILE_SPECIFIER_APP='CurtainCall_AppStore' PROVISIONING_PROFILE_SPECIFIER_WIDGET='CurtainCall_Widget_AppStore' -allowProvisioningUpdates",
      export_options: {
        provisioningProfiles: {
          "com.junil.CurtainCall" => "CurtainCall_AppStore",
          "com.junil.CurtainCall.CurtainCallWidget" => "CurtainCall_Widget_AppStore"
        }
      }
    )

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      notify_external_testers: false
    )

    # 빌드 번호는 latest_testflight_build_number + 1로 자동 계산되므로
    # 커밋할 필요 없음
    UI.success("✅ Successfully uploaded to TestFlight!")
  end

  # MARK: - App Store Deployment

  desc "Upload a new build to App Store"
  lane :release do
    prepare_secrets_xcconfig

    # Import certificate and provisioning profile
    import_certificate(
      certificate_path: ENV["P12_PATH"],
      certificate_password: ENV["P12_PASSWORD"],
      keychain_name: "fastlane_tmp_keychain"
    )

    install_provisioning_profile(
      path: ENV["PROFILE_PATH"]
    )

    # Install widget provisioning profile
    if ENV["PROFILE_WIDGET_PATH"]
      install_provisioning_profile(
        path: ENV["PROFILE_WIDGET_PATH"]
      )
    end

    # App Store Connect API Key
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"]
    )

    # Increment build number
    increment_build_number(
      build_number: latest_testflight_build_number + 1,
      xcodeproj: XCODEPROJ_PATH
    )

    # Build the app
    build_app(
      project: XCODEPROJ_PATH,
      scheme: "CurtainCall",
      configuration: "Release",
      derived_data_path: "./derived_data",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "CurtainCall.ipa"
    )

    # Upload to App Store
    upload_to_app_store(
      skip_metadata: true,
      skip_screenshots: true,
      submit_for_review: false,
      automatic_release: false
    )

    UI.success("✅ Successfully uploaded to App Store!")
  end

  # MARK: - Utility Lanes

  desc "Download certificates and provisioning profiles"
  lane :sync_certificates do
    match(
      type: "appstore",
      readonly: true
    )
  end

  desc "Register new devices"
  lane :register_devices do
    register_devices(
      devices_file: "./fastlane/devices.txt"
    )
  end

  # MARK: - Error Handling

  error do |lane, exception|
    UI.error("Error in lane #{lane}: #{exception.message}")
  end
end
